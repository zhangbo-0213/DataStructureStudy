// 链栈.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include "stdio.h"
#include "io.h"
#include "math.h"
#include "time.h"
#include "stdlib.h"


#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 20

typedef int Status;
typedef int SElemType;

//定义节点
typedef struct StackNode {
	SElemType data;
	struct StackNode *next;
}StackNode,*LinkStackPtr;

typedef struct {
	LinkStackPtr top;
	int count;
}LinkStack;

//构造空栈
Status InitStack(LinkStack *S) {
	S->top = (LinkStackPtr)malloc(sizeof(StackNode));
	if (!S->top)
		return ERROR;
	S->top = NULL;
	S->count = 0;
	return OK;
}

//清空栈
Status ClearStack(LinkStack *S) {
	LinkStackPtr p, q;
	p = S->top;
	while (p) {
		q = p;
		p = p->next;
		free(q);
	}
	S->count = 0;
	return OK;
}

//栈是否为空
Status StackEmpty(LinkStack S) {
	if (S.count == 0)
		return TRUE;
	else
		return FALSE;
}

int StackLength(LinkStack S) {
	return S.count;
}

//获得栈顶元素
Status GetTop(LinkStack S, SElemType *e) {
	if (S.top == NULL)
		return ERROR;
	else
		*e = S.top->data;
	return OK;
}

//入栈操作
Status Push(LinkStack *S, SElemType e) {
	LinkStackPtr s = (LinkStackPtr)malloc(sizeof(StackNode));
	s->data = e;
	s->next = S->top;
	S->top = s;
	S->count++;
	return OK;
}

//出栈操作
Status Pop(LinkStack *S, SElemType *e) {
	if (StackEmpty(*S))
		return ERROR;
	LinkStackPtr p;
	p = S->top;
	*e = p->data;
	S->top = p->next;
	free(p);
	S->count--;
	return OK;
}

Status visit(SElemType c)
{
	printf("%d ", c);
	return OK;
}

Status StackTraverse(LinkStack S) {
	LinkStackPtr p;
	p = S.top;
	while (p) {
		visit(p->data);
		p = p->next;
	}
	printf("\n");
	return OK;
}
int main()
{
	int j;
	LinkStack s;
	int e;
	if (InitStack(&s) == OK)
		for (j = 1; j <= 10; j++)
			Push(&s,j);
	printf("栈中的元素依次为：");
	StackTraverse(s);
	Pop(&s,&e);
	printf("弹出的元素 e=%d\n",e);
	printf("栈空否：%d(1:空 0:否)\n",StackEmpty(s));
	GetTop(s,&e);
	printf("栈顶元素 e=%d 栈的长度为%d\n",e,StackLength(s));
	ClearStack(&s);
	printf("清空栈后，栈空否：%d(1:空 0:否",StackEmpty(s));

    return 0;
}

